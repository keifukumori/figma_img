# Figma to HTML システム設計 - 思考プロセス記録

## 1. プロジェクト発端とアプローチの変遷

### 1.1 初期課題：画像整理の問題
**発端の問題:**
```
現状: 複数のFigmaデザインから画像を取得すると、全て同一ディレクトリに保存される
課題: どのデザインから取得した画像かが判別できない
```

**解決アプローチ:**
```
思考: プロジェクト名とフレーム名でサブディレクトリを自動作成
実装: file_data.get("name") + target_frame.get("name") でディレクトリ構造化
結果: figma_images/[プロジェクト名]/[フレーム名]/ の階層化実現
```

### 1.2 オートコーディングへの発展
**発想の転換点:**
```
ユーザー質問: 「画像以外のデータも取得できるか？オートコーディングに使いたい」
```

**思考プロセス:**
```
1. Figma APIで取得可能なデータの洗い出し
   - レイアウト・スタイル情報 (x, y, width, height, fills, fonts)
   - 階層構造データ (parent-child関係, 命名規則)
   - インタラクション情報 (プロトタイプ、状態管理)

2. 用途別の重要度評価
   静的コーディング用途:
   ✓ 必須: レイアウト・スタイル、階層構造
   △ 不要: インタラクション（除外決定）

3. 技術的実現可能性の評価
   HTML/CSS生成: 技術的に可能
   React/Vueコンポーネント: より高度だが可能
```

## 2. 複雑性レベルの分析と対応範囲の絞り込み

### 2.1 複雑性の段階的分類
**思考の背景:**
```
問題: 「すべてのレイアウトを完璧に変換」は現実的でない
アプローチ: 複雑性レベルを分類し、対応可能範囲を明確化
```

**分類結果と判断根拠:**

#### ほぼ自動化OK（90%以上精度）
```
対象:
- 基本要素（ボタン、テキスト、画像）
- 単純配置（縦並び、横並び、重ね合わせ）

判断理由:
- Figma APIから直接的にデータ取得可能
- CSS変換ロジックが明確
- 例外ケースが少ない
```

#### やや難しい（70%程度精度）
```
対象:
- 4×3グリッド配置
- サイドバー + メインコンテンツ
- ヘッダー・フッター構造

判断理由:
- レイアウトパターンの推測が必要
- 複数の実装方法が考えられる（Grid vs Flexbox）
- デザイナーの意図の解釈が必要
```

#### かなり難しい（30%以下精度）
```
対象:
- 不規則なマルチカラム
- 複雑な重なり関係
- 5階層以上のネスト

判断理由:
- 自動判定が困難
- 人間の設計判断が必要
- エラー率が高すぎて実用性に欠ける
```

### 2.2 実用的な範囲への絞り込み戦略
**ユーザーからの提案:**
```
「すべてを一度にやろうとせず、対応箇所を絞る」
「デザイナーがフルで作った複雑要素は省く」
「ワイヤーフレームに近い内容はしっかり反映」
```

**この提案の優秀性:**
```
✓ 現実的な精度目標設定（85%程度）
✓ 明確な除外基準（ブランド固有要素等）
✓ 高需要領域への集中（ワイヤーフレーム→実装の工程）
```

### 2.3 共通部品除外の設計判断
**重要な設計変更:**
```
当初想定: ヘッダー・フッター・ナビゲーションも自動生成
ユーザー指摘: 「共通部品はインクルードファイルで用意済み」
結果: メインコンテンツエリアに特化
```

**この変更の影響:**
```
✓ 処理対象の明確化
✓ 複雑性の大幅削減
✓ より高精度な生成が可能
✓ 実用性の向上
```

## 3. レスポンシブ対応の技術課題と解決策

### 3.1 レスポンシブ判定の課題認識
**技術的課題:**
```
問題: Flexboxの justify-content: space-between vs space-around の判定
問題: flex-grow の適用箇所の特定
問題: ブレークポイントの自動設定
```

**現実的な制約:**
```
Figma APIから取得可能な情報:
✓ 要素の絶対位置・サイズ
✓ Auto Layout設定（一部）
× デザイナーの意図（space-between等）
× ブレークポイントの設計思想
```

### 3.2 PC・SP版同時取得アプローチの検証
**提案の評価プロセス:**
```
ユーザー質問: 「SP版も同時に渡すことで判定の手助けになるか？」

検討1: 判定精度への効果
PC版: 横4列配置
SP版: 縦1列配置
→ CSS Grid with auto-fit が確定判定可能

検討2: 処理量への影響  
データ量: 2倍
処理複雑性: 要素マッチング処理が追加
→ しかし実用性は格段に向上

結論: 処理は複雑になるが、価値は十分
判定精度: 60% → 85%程度に向上
```

**実装方針:**
```
1. PC版で基本構造生成
2. SP版で差分検出
3. 共通パターンをテンプレート化
4. 差分部分をメディアクエリ化
```

## 4. コンテキスト制約の発見と解決策の発案

### 4.1 処理量制約の現実認識
**制約の発見:**
```
ユーザー想定: 1万ピクセル級のページを一括処理
Claude制限: 約200,000トークン（約150,000文字相当）

現実的な処理容量:
中規模LP: 100-300KB → 処理可能
大規模ページ: 800KB-1.5MB → 容量超過
1万ピクセル級: 完全に容量超過
```

**問題の深堀り:**
```
PC版: 8,000px, 200-400要素
SP版: 15,000-20,000px, 300-600要素（リスト展開で増加）
→ 分割処理が必須
```

### 4.2 セクション数と判定精度のトレードオフ分析
**ユーザーからの鋭い指摘:**
```
「10セクション見るとコンテキスト量が膨大になるのでは？」
「ノイズが多くなるのでは？」
```

**トレードオフの詳細分析:**
```
3セクション:
✓ コンテキスト: 50-100KB（軽量）
✓ ノイズ: 少ない
× 判定精度: 80%（サンプル不足リスク）

10セクション:
× コンテキスト: 200-400KB（重量）
× ノイズ: 多い（サイドバー等混入）
✓ 判定精度: 95%（統計的に安定）
```

### 4.3 階層別取得アプローチの発案
**解決策の創案プロセス:**
```
課題: 判定精度 vs コンテキスト効率の両立

発想: 「外側要素から順に取る」
Phase 1: ラッパー・構造情報のみ（軽量）
Phase 2: セクション内詳細（重量、1つずつ）

効果検証:
従来: 10セクション × 詳細 = 400KB（容量超過）
階層別: 
- Phase1: 10セクション × 構造のみ = 50KB
- Phase2: 1セクション × 詳細 = 40KB × N回
→ 合計処理可能 + 高精度
```

**この手法の優秀性:**
```
✓ 10セクション分の構造把握可能
✓ コンテキスト量制御
✓ 高精度なラッパー判定
✓ 統計的に安定した判定
```

## 5. ラッパー・インナー紐付けの技術検証

### 5.1 紐付け課題の具体化
**ユーザーからの詳細確認:**
```
「10セクション見てラッパーとインナーのパターンを見つけた後、
1セクション目の中身要素をどうやってラッパー・インナーと紐付けるか？」
```

**技術的課題の整理:**
```
Phase1で検出: wrapper_width=1200, inner_width=1000
Phase2で取得: section1の詳細要素群
問題: どの要素がwrapper、どれがinnerか？
```

### 5.2 紐付けロジックの設計
**解決アプローチ:**
```python
# パターンマッチング手法
def assign_elements_to_containers(section_data, patterns):
    for element in section_data['children']:
        # 1. 幅での判定
        if element['width'] == patterns['wrapper_pattern']['width']:
            element['role'] = 'wrapper'
            
        # 2. 階層レベルでの判定
        if element['nesting_level'] == patterns['wrapper_pattern']['level']:
            element['role'] = 'wrapper'
            
        # 3. 命名規則での判定
        if 'Container' in element['name']:
            element['role'] = 'wrapper'
```

**IDベースの追跡:**
```python
# Figma固有IDでの確実な追跡
section_mapping = {
    "section1": {
        "wrapper_id": "1:200",
        "inner_id": "1:201",
        "content_ids": ["1:202", "1:203", "1:204"]
    }
}
```

### 5.3 3カラム・ギャラリー等の複雑要素対応
**具体的な検証:**
```
ユーザー確認: 「3カラム要素や画像並び要素がある場合の整合性」

技術検証:
1. 幅の整合性チェック
   total_content_width <= inner_width で overflow検出

2. 相対位置の正規化
   content.relative_x = content.absolute_x - inner.absolute_x

3. レイアウトパターンの自動判定
   等間隔 + 等幅 → grid-template-columns: repeat(3, 1fr)
   画像中心 → image-gallery クラス適用
```

## 6. セクション自動検出手法の比較検討

### 6.1 検出手法の優先順位設計
**手法の評価:**
```
1位: Figmaフレーム構造（85%精度）
理由: デザイナーが意図的に設定した境界
実装: Auto Layoutフレームの検出

2位: レイヤー命名規則（70%精度）  
理由: 命名パターンから意図を推測
実装: "Section", "Hero", "Features"等の検出

3位: Y座標 + 要素密度（60%精度）
理由: 機械的だが確実なフォールバック
実装: 大きな空白エリアでの分割

4位: デフォルト分割（画面単位等）
理由: 最後の手段
```

**この優先順位の根拠:**
```
思考: デザイナーの意図に近い順番で検出精度が高い
検証: 実際のFigmaファイルでの成功率を想定
結論: 複数手法の組み合わせで高精度化
```

## 7. 料金・制約事項の確認プロセス

### 7.1 Figma API料金への懸念
**ユーザーからの慎重な確認:**
```
「API呼び出しは料金がかからないということでよいか？」
```

**詳細調査と回答:**
```
Figma API:
✓ 基本的に無料
✓ 制限: 1000回/時間
△ 商用大規模利用は要確認

Claude Code:
✓ API呼び出し自体は追加料金なし
△ Claude自体の利用料金は発生
△ 大量データ処理時のトークン消費に注意
```

### 7.2 実用的影響の評価
**現実的な利用範囲での検証:**
```
小～中規模利用:
- 月数十～数百ページ処理 → 実質無料範囲
- 開発・プロトタイプ段階 → 問題なし

大規模商用利用:
- 月数千ページ以上 → Figma側制限に注意
- エンタープライズ利用 → 別途確認推奨
```

## 8. 技術アーキテクチャの設計思想

### 8.1 段階的処理アーキテクチャの設計
**設計思想:**
```
問題: 一括処理では容量制約に引っかかる
解決: 軽量処理 → 重量処理の段階的アプローチ

Phase 1: 構造解析（軽量）
- 目的: 全体構造の把握
- 処理: ラッパー幅、セクション境界の検出
- データ量: 約50KB

Phase 2: 詳細解析（重量）  
- 目的: セクション単位のHTML生成
- 処理: 要素配置、スタイル詳細の変換
- データ量: 約40KB/セクション
```

### 8.2 スマートサンプリング戦略
**効率的なデータ取得:**
```
問題: 10セクション分析したいが、コンテキスト制約がある
解決: 代表的なセクションの選択

選択ロジック:
- sections[0]: 最初（Hero等の重要セクション）
- sections[len//2]: 中間（典型的なコンテンツセクション）
- sections[-1]: 最後（CTA等の重要セクション）
- + ランダム2セクション（多様性確保）
```

## 9. システム設計の核心思想

### 9.1 実用性重視の設計判断
**完璧性 vs 実用性:**
```
選択: 「7割完成度でも実用的」を重視
根拠: 手動調整前提でも大幅な工数削減効果
結果: 現実的な精度目標（85%）設定
```

### 9.2 段階的実装戦略
**拡張性を考慮した設計:**
```
Phase 1: 基本的なワイヤーフレーム要素
Phase 2: 中程度の複雑なレイアウト
Phase 3: 高度な機能（JavaScript生成等）

利点: リスク分散、段階的価値提供
```

### 9.3 既存システム活用の発想
**効率的な開発アプローチ:**
```
基盤: 既存のfetch_figma_images.pyを拡張
利点: 
- Figma API接続設定が既に存在
- .env設定の再利用
- 段階的な機能追加が可能
```

## 10. 今後の展開における思考

### 10.1 学習・改善サイクルの設計
**継続的改善の仕組み:**
```
1. パターン認識の精度向上
   - 実際の変換結果から学習
   - よくある失敗パターンの蓄積

2. テンプレート化の促進
   - 成功パターンのテンプレート化
   - 業界・用途別のテンプレート作成
```

### 10.2 拡張可能性の考慮
**将来的な機能拡張:**
```
短期: CSS Framework対応（Bootstrap、Tailwind）
中期: 基本的なJavaScript生成
長期: AI学習による精度向上

設計思想: モジュール式で拡張しやすい構造
```

## 11. 結論

### 11.1 設計の核心価値
```
1. 現実的な精度目標設定
2. 明確な対応範囲の絞り込み  
3. 技術制約を考慮した段階的アプローチ
4. 実用性重視の機能設計
```

### 11.2 成功要因の分析
```
✓ ユーザーとの詳細な要件すり合わせ
✓ 技術的制約の早期認識と対策
✓ 段階的な複雑性への対応
✓ 既存システムの活用による効率化
```

この思考プロセス記録により、なぜこの設計になったのか、どのような検討を経てこの結論に至ったのかが明確になり、今後の開発や改善において貴重な参考資料となる。